#include "task/algorithm/exploit_repair.hh"

#include <cstring>

namespace exr {

//Constructor and destructor
ExploitRepair::ExploitRepair(const Count &k, const Count &num,
                             const Count &rid, const Count &task_num,
                             const Path &bw_path)
    : RouteCalculator(rid, bw_path), k_(k), num_(num),
      bandwidths_(new Bandwidth[num]), raw_bandwidths_(new Bandwidth[num]),
      task_num_(task_num), max_bw_(0), base_(0), is_upload_limit_(true),
      nodes_(nullptr), tasks_(nullptr) {}

ExploitRepair::~ExploitRepair() = default;

//Fill the information
Count ExploitRepair::GetTaskNumber(const Count &gid) {
  return gid == 0 ? max_bw_ : 0;
}

void ExploitRepair::FillTask(const Count &gid, const Count &tid,
                             const Count &node_id,
                             RepairTask &rt, Count *src_ids) {
  if (node_id > num_) {
    rt.size = 0;
    return;
  }
  //Check if is chosen
  Count nid = node_id - 1;
  if (!(nodes_[nid * max_bw_ + tid])) {
    rt.size = 0;
    return;
  }

  //Fill the target and bandwidth
  auto cur_task = tasks_.get() + tid * num_;
  rt.tar_id = (cur_task[nid] % num_) + 1;
  rt.bandwidth = base_;

  //Find out the sources
  rt.src_num = 0;
  for (Count i = 0; i < num_; ++i)
    if (cur_task[i] == nid)
      src_ids[(rt.src_num)++] = i + 1;

  //Allocate the offset and size
  auto ss = rt.offset + rt.size;
  rt.size /= max_bw_;
  rt.offset += rt.size * tid;
  if (tid == max_bw_ - 1)
    rt.size = ss - rt.offset;
}

BwType ExploitRepair::get_capacity() { return max_bw_ * base_; }

//Calculate and get the repair route
Count ExploitRepair::CalculateRoute(const Bandwidth *bws,
                                    const Count &rid) {
  //Copy all the bandwidth and calculate the limit
  std::memcpy(bandwidths_.get(), bws, sizeof(Bandwidth) * num_);
  AnalyzeBandwidth_();
  if (max_bw_ == 0) return 0;

  //Quantify the bandwidths and re-calculate the limit
  std::memcpy(raw_bandwidths_.get(),
              bandwidths_.get(), sizeof(Bandwidth) * num_);
  base_ = max_bw_ / task_num_ + 1;

  do {
    --base_;
    for (Count i = 0; i < num_; ++i) {
      bandwidths_[i].upload = raw_bandwidths_[i].upload / base_;
      bandwidths_[i].download = raw_bandwidths_[i].download / base_;
    }
    AnalyzeBandwidth_();
    if (max_bw_ == 0) return 0;
  } while (max_bw_ < task_num_);

  //Dis
  if (!DistributeTasks_()) return 0;

  //Match
  if (AddAMatch_(rid - 1, 0)) {
    for (Count i = 0; i < max_bw_; ++i) {
      nodes_[(rid - 1) * max_bw_ + i] = true;
    }
    return 1;
  } else {
    return 0;
  }
}

void ExploitRepair::AnalyzeBandwidth_() {
  //Get limit by uploads
  auto is_biggest = std::make_unique<bool[]>(num_);
  for (Count i = 0; i < num_; ++i) is_biggest[i] = false;
  Count divider = k_;
  while (true) {
    BwType max_upload = 0, sum_upload = 0;
    for (Count i = 0; i < num_; ++i) {
      if (!is_biggest[i]) {
        auto &new_bw = bandwidths_[i].upload;
        sum_upload += new_bw;
        max_upload = new_bw > max_upload ? new_bw : max_upload;
      }
    }
    max_bw_ = sum_upload / divider;

    if (max_upload <= max_bw_) break;

    for (Count i = 0; i < num_; ++i) {
      if (bandwidths_[i].upload == max_upload) {
        is_biggest[i] = true;
        --divider;
      }
    }
  }

  //Adjust the limit by downloads
  BwType sum_download = 0;
  is_upload_limit_ = true;
  for (Count i = 0; i < num_; ++i) sum_download += bandwidths_[i].download;
  if (max_bw_ * k_ > sum_download) {
    is_upload_limit_ = false;
    max_bw_ = sum_download / k_;
  }

  for (Count i = 0; i < num_; ++i)
    if (bandwidths_[i].upload > max_bw_) bandwidths_[i].upload = max_bw_;
}

bool ExploitRepair::DistributeTasks_() {
  //Limit the uplaod bandwidth
  if (is_upload_limit_) {
    BwType sum_upload = 1;
    for (Count i = 0; i < num_; ++i)
      sum_upload += bandwidths_[i].upload;
    while (--sum_upload > max_bw_ * k_) {
      Count limit_id = 0;
      BwType max_upload = 0;
      for (Count i = 1; i < num_; ++i) {
        if (bandwidths_[i].upload > max_upload) {
          max_upload = bandwidths_[i].upload;
          limit_id = i;
        }
      }
      bandwidths_[limit_id].upload -= 1;
    }
  } else {
    //Sum up the downloads
    BwType remain = max_bw_ * k_, sum_download = 0;
    auto filled = std::make_unique<bool[]>(num_);
    for (Count i = 1; i < num_; ++i) {
      filled[i] = false;
      sum_download += bandwidths_[i].download;
    }

    while (remain > 0) {
      //Find out the biggest
      BwType max_download = 0;
      Count max_id = 0;
      for (Count i = 1; i < num_; ++i) {
        if (!filled[i] && bandwidths_[i].download > max_download) {
          max_download = bandwidths_[i].download;
          max_id = i;
        }
      }
      if (sum_download == 0) {
        max_bw_ = 0;
        return false;
      }

      //Limit the biggest one
      auto &new_fill = bandwidths_[max_id];
      auto new_limit = new_fill.download * remain / sum_download;
      if (new_fill.upload > new_limit) new_fill.upload = new_limit;
      sum_download -= new_fill.download;
      remain -= new_fill.upload;
      filled[max_id] = true;
    }
  }

  //Init the matrix and assign the tasks
  nodes_ = std::make_unique<bool[]>(num_ * max_bw_);
  tasks_ = std::make_unique<Count[]>(max_bw_ * num_);
  for (Count i = 0; i < num_ * max_bw_; ++i) {
    nodes_[i] = false;
    tasks_[i] = num_;
  }
  Count cur_task = 0;
  for (Count node_id = 0; node_id < num_; ++node_id) {
    for (Count i = 0; i < bandwidths_[node_id].upload; ++i) {
      nodes_[node_id * max_bw_ + cur_task] = true;
      cur_task = (cur_task + 1) % max_bw_;
    }
  }
  return true;
}

bool ExploitRepair::AddAMatch_(const Count &rid, Count cur_match) {
  while (cur_match < num_ * max_bw_ && !nodes_[cur_match]) ++cur_match;
  //Check if is done
  if (cur_match >= num_ * max_bw_) {
    for (Count task_id = 0; task_id < max_bw_; ++task_id) {
      bool contain = false;
      for (Count node_id = 0; node_id < num_; ++node_id) {
        if (tasks_[task_id * num_ + node_id] == rid) {
          contain = true;
          break;
        }
      }
      if (!contain) return false;
    }
    return true;
  }

  Count cur_node = cur_match / max_bw_, cur_task = cur_match % max_bw_;
  for (Count node_id = 0; node_id < num_; ++node_id) {
    if ((node_id != cur_node) && (bandwidths_[node_id].download > 0) &&
        (nodes_[node_id * max_bw_ + cur_task] || node_id == rid)) {
      auto tem_node = node_id;
      do {
        tem_node = tasks_[cur_task * num_ + tem_node];
      } while (tem_node != num_ && tem_node != cur_node);

      if (tem_node == num_) {
        bandwidths_[node_id].download -= 1;
        tasks_[cur_task * num_ + cur_node] = node_id;

        if (AddAMatch_(rid, cur_match + 1)) return true;

        tasks_[cur_task * num_ + cur_node] = num_;
        bandwidths_[node_id].download += 1;
      }
    }
  }
  return false;
}

} // namespace exr
